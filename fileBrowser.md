**برنامه‌ی کاوشگر فایل**

- **نویسنده**: احمد کنی
- **تاریخ**: ۲۳ بهمن ۱۴۰۳  
- **وضعیت**: پیش‌نویس/~~در حال بررسی~~/~~تایید شده~~

---
## **خلاصه**

این برنامه به عنوان یک برنامه‌ی نوشته شده با pure javascript و با استفاده از قابلیت‌های service worker و git، این امکان را به کاربر می‌دهد تا با استفاده از این کاوشگر فایل، اسناد را ایجاد، ویرایش و یا حذف کند.
این برنامه مانند یک native file explorer کار می‌کند و بدون اینکه کاربر را با قابلیت‌های git مواجه کند، امکان استفاده از قابلیت‌های git را به او می‌دهد.

---

## **سامانه‌ی فایل‌بندی**

برای این برنامه نیاز به استفاده از چند سامانه وجود دارد. اولین و اساسی‌ترین سامانه، سامانه‌ی فایل‌بندی یا file system است. این سامانه باید طوری باشد که بتواند به تنهایی و بدون هیچ وابستگی‌ای به ما امکان کار کردن با فایل‌ها را در محیط مرورگر بدهد.
این سامانه یک سامانه مشابه node fs خواهد بود که به ما امکان کار کردن با فایل‌ها را در محیط‌های مختلف مانند حافظه‌ی داخلی، indexed db، cache، دیسک و سایر حافظه‌ها می‌دهد.
از این جهت که ما با حافظه‌ها و محیط‌های مختلفی درگیر هستیم نیاز است تا یک fs مجازی مشابه چیزی که در لینوکس وجود دارد ایجاد شود تا این vfs به عنوان یک interface میان ما و fs های متفاوت وجود داشته باشد و عملاً دسترسی ما به خود fs backend ها را محدود و پیچیدگی کار با fs های مختلف را دور از دید ما حل می‌کند و به ما از طریق یک interface به نام vfs امکان کار با fs های مختلف را می‌دهد.
همچنین برای کار با fs های متفاوت و سرعت بخشیدن به ارتباط‌گیری با آنها و مدیریت آنها نیاز به ایجاد مفهوم mount کردن در این vfs داریم.

### **رابط VFS**

این رابط را به صورت یک کلاس در کد جاوااسکریپت تعریف می‌شود که وظیفه دارد متدهای اصلی fs ها را تعریف کند و ارتباط میان آنها، نحوه‌ی کار آنها با یکدیگر و فرآیندهای اساسی را برای آنها تعریف کند.

```
class VFS { 
	constructor(defaultFSType = null) {
		this.fsType = defaultFSType || detectFS();
		this.mounts = {};
	} 
	
	createFSInstance(fsType, options) {...}
	mount(path, fsInstance) {...} 
	unmount(path) {...} 
	resolveFS(path) {...}
```

در کلاس vfs ما با استفاده از کلاس createFSInstance یکی از فضاهای حافظه را که قبل‌تر شرح دادیم، انتخاب می‌کنیم، سپس با استفاده از آن تمام عملیات دیگر را می‌توانیم انجام دهیم. به این صورت که هر موجودیت fs یا FS Instance متدهای read, write, delete, list, rename را دارد و در context مربوط به خودش تعریف و عملیات آن تعریف شده است، با انتخاب آن موجودیت امکان استفاده از آن متدها و ارتباط گیری با هر fs را پیدا می‌کنیم.
به طور مثال کلاس مربوط به memory به این صورت تعریف می‌شود:

```
class MemoryFS {
  constructor() {
    this.store = {};
  }

  async writeFile(path, content) {
    this.store[path] = content;
  }

  async readFile(path) {
    return this.store[path] || null;
  }

  async deleteFile(path) {
    delete this.store[path];
  }

  async listFiles() {
    return Object.keys(this.store);
  }
}
```

این کلاس و هر کلاس مربوط به fs ها متدهای اساسی را پیاده‌سازی می‌کنند و امکان استفاده از fs های متفاوت را به ما می‌دهند.

#### **مفهوم mount کردن**

برای این که دسترسی سریع‌تری به مسیرهای موجود در یک fs داشته باشیم و بتوانیم با یک فایل در آن کار کنیم، از این مفهوم استفاده می‌کنیم. همچنین برای خالی کردن حافظه‌ی داخلی از اطلاعات اضافی‌ای که فعلا با آن کاری نداریم و همین‌طور کم کردن پیچیدگی و جلوگیری از خطا از مفهوم unmount که مخالف mount است استفاده می‌کنیم.
برای پیاده‌سازی این مفهوم از یک جدول و دو تابع استفاده می‌کنیم:
- جدول mount پیاده‌سازی مرتبط با یک object جاوااسکریپتی است: 

```
this.mounts = {
  "/cache": LocalStorageFS,  // Handles all files under "/cache"
  "/tmp": MemoryFS           // Handles all files under "/tmp"
};
```

- این ساختمان داده به ما کمک می‌کند تا در صورتی که یک آدرس را داشتیم و نیاز به تشخیص fs استفاده شده در آن داشتیم بتوانیم اطلاعات مهمی را از جدول زیر بگیریم:‌

| Path              | Matches Mount Point | Filesystem Used        |
| ----------------- | ------------------- | ---------------------- |
| `/cache/test.txt` | `/cache`            | LocalStorageFS         |
| `/tmp/notes.txt`  | `/tmp`              | MemoryFS               |
| `/global.txt`     | `No match`          | Default FS (IndexedDB) |
- همچنین توابع mount و unmount مقادیر fs را به شیء mounts اضافه و یا از آن کم می‌کنند. همچنین با استفاده از این توابع می‌توانیم آدرس‌ها و پارامترهای موقت را حذف و اضافه کنیم.

#### **عملیات‌ در vfs **

پس از تعریف vfs و همچنین کلاس‌های حافظه، اکنون می‌توانیم عملیات CRUD را در vfs تعریف کنیم و همچنین از آنها استفاده کنیم.
ابتدا برای استفاده از fs ها و همچنین تعریف عملیات در آنها نیاز داریم تا به فایل اصلی .git دسترسی داشته باشیم.
این کار در هر محیط به یک صورت انجام می‌شود که در کلاس‌های حافظه آنها را تعریف کرده‌ایم و سپس می‌توانیم روی این فایل اصلی عملیات CRUD را انجام دهیم که در سرفصل بعدی مفصلاً تشریح خواهد شد.

---

## **عملیات CRUD**

برای پیاده سازی عملیات CRUD در سیستم، آنها را به شکل زیر با ترکیب عملیات fs با عملیات git انجام می‌دهیم:
1. **ایجاد (*C*) :** در این عمل، کاربر می‌تواند دو نوع فایل و پوشه را ایجاد کند، همچنین این عملیات عمل‌های پایه‌ای برگرفته از isomorphic git هستند که بدون بازکردن مسیرها و پوشه‌ها می‌توان آن‌ها را استفاده کرد. 
		**(همچنین قابل ذکر است که برای احراز هویت کاربر و امضای دیجیتال و همچنین پی بردن به هویت شخص ایجادکننده‌ی فایل می‌توانیم از commit's author استفاده کنیم.)
	- برای ایجاد فایل از این سلسله عملیات استفاده می‌کنیم: 
		- Git.WriteFileOnDotGit(filePath)
		- Git.commit(commitMessage : File *A* Created by User *A* with IP Address *1.1.1.1*) 
	- برای ایجاد پوشه از این سلسله عملیات استفاده می‌کنیم:
		- Git.mkdirRecursively(dirPath)
		- Git.commit(commitMessage : directory */A* Created by User *A* with IP Address *1.1.1.1*)

2. **خواندن (*R*):** در این عمل، کاربر محتوای یک فایل یا پوشه را می‌خواند:
	- برای خواندن محتوای یک فایل از تک عمل Git.readFileFromDotGit استفاده می‌کنیم، این عمل با استفاده از توابع پایه‌ای isomorphic git مانند readBlob قابل پیاده‌سازی است و کارکرد آن به این صورت است که فایل را از آخرین commit انجام شده می‌خواند.
	- برای خواندن محتوای یک پوشه از عمل Git.listFilesFromDotGit استفاده می‌کنیم این عمل نیز با استفاده از دستورات پایه است و لیست فایل‌ها را بدن بازکردن و خواندن فایل‌ها و پوشه‌ها از طریق دسترسی به درخت‌های ایجاد شده توسط گیت لیست می‌کند.
	
3. **به‌روزرسانی (*U*):** دو مدل به روزرسانی وجود دارد که به ترتیب سلسله عملیات مربتط با هرکدام را نیز می‌گوییم، این عملیات عمل‌های پایه‌ای برگرفته از isomorphic git هستند که بدون بازکردن مسیرها و پوشه‌ها می‌توان آن‌ها را استفاده کرد:
	- به روزرسانی محتوای یک فایل: 
		- Git.WriteFileOnDotGit(filePath)
		- Git.commit(commitMessage : File *A* Updated by User *A* with IP Address *1.1.1.1*)
	- به روزرسانی نام یک فایل یا پوشه:
		- Git.rename(oldname, newname)
		- Git.commit(commitMessage : File *A* renamed by User *A* with IP Address *1.1.1.1*)

4. **حذف (*D*):** این عمل برای دو نوع فایل و پوشه قابل انجام است:
	- برای حذف یک فایل از این سلسله عملیات استفاده می‌کنیم:
		- Git.remove(filePath)
		- Git.commit(commitMessage : File *A* removed by User *A* with IP Address *1.1.1.1*)


	- برای حذف یک پوشه از این سلسله عملیات استفاده می‌کنیم:
		- Git.removeRecursively(filePath)
		- Git.commit(commitMessage : directory *A* removed by User *A* with IP Address *1.1.1.1*)

این سلسله عملیات ها توسط توابع مرتبط با آنها پیاده خواهند شد.

---

## **همگام‌سازی با ریموت**

برای همگام‌سازی داده‌ی محلی با داده‌ی ریموت چند گزینه در اختیار کاربر قرار می‌دهیم که می‌تواند از بین آنها یکی را برای استراتژی همگام‌سازی خود انتخاب کند:

5. همگام‌سازی دستی : به این صورت است که کاربر همگام‌سازی  را تنها هنگامی انجام می‌دهد که خودش بخواهد و همگام‌سازی خودکار انجام نمی‌شود.
6. همگام‌سازی زمان‌محور: در این حالت همگام‌سازی های بازه‌ای انجام می‌شود، به این صورت که کاربر تعیین می‌کند پس از بازه‌های زمانی مشخصی این همگام‌سازی‌ها انجام شود.
7. همگام‌سازی رخدادمحور: در این مدل کاربر تعیین می‌کند که همگام‌سازی  پس از رخداد خاصی انجام شود، مثلا هنگام خروج کاربر از برنامه، یا هنگام ورود.

این تنظیمات را باید در یک قسمت مشخص برای کاربر ایجاد کنیم و اجازه‌ی ویرایش آن را به کاربر بدهیم.
این تنظیمات در یک فایل خاص در پوشه‌ی .git برای کاربر ایجاد  و از آنجا خوانده می‌شود.
